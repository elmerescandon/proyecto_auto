#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import rospy
import numpy as np
from geometry_msgs.msg import PoseStamped
from hector_uav_msgs.msg import PoseActionGoal
import functions as num



# Clase del suscriptor 
class suscriptor_quadrotor_pose():
	def __init__(self):
		topic = '/ground_truth_to_tf/pose'
		self.pose_actual = PoseStamped()
		self.pub = rospy.Subscriber(topic,PoseStamped,self.callback_points)
	def callback_points(self,msg):
		self.pose_actual = msg
		# print(self.pose_actual.pose.position.x)
	def get_pose(self): 
		x_act = self.pose_actual.pose.position.x
		y_act = self.pose_actual.pose.position.y
		z_act = self.pose_actual.pose.position.z
		x_q_act = self.pose_actual.pose.orientation.x
		y_q_act = self.pose_actual.pose.orientation.y
		z_q_act = self.pose_actual.pose.orientation.z
		w_act = self.pose_actual.pose.orientation.w
		return np.array([x_act,y_act,z_act,x_q_act,y_q_act,z_q_act,w_act])



# Inicializar el nodo
rospy.init_node('init_quadrotor')
	
topic_pub = '/action/pose/goal'
pub = rospy.Publisher(topic_pub,PoseActionGoal,queue_size=10)
pose_quadrotor = PoseActionGoal()

# Definir el objeto sub
sub = suscriptor_quadrotor_pose()


# Iniciar despegue del robot

z_takeoff = 1.1
y_beer_close = 18
x_beer_close = 37

pose_quadrotor.goal.target_pose.header.frame_id = "world"
quadrotor_pos = pose_quadrotor.goal.target_pose.pose.position 
quadrotor_or = pose_quadrotor.goal.target_pose.pose.orientation

# Actualizar posici√≥n cartesiana del robot
R = num.rotaxis(np.deg2rad(90),'z')#.dot(num.rotaxis(np.deg2rad(30),'x'))
q = num.rot2quat(R)

pub.publish(pose_quadrotor)   


# pose_actual = np.array([x_act,y_act,z_act])

rate = rospy.Rate(50)

while not rospy.is_shutdown():
	med = sub.get_pose() 
	quadrotor_pos.x = x_beer_close #med[0]
	quadrotor_pos.y = y_beer_close #med[1]
	quadrotor_pos.z = z_takeoff
	quadrotor_or.x = q[0]
	quadrotor_or.y = q[1] 
	quadrotor_or.z = q[2]
	quadrotor_or.w = q[3]
	des = np.array([x_beer_close,y_beer_close,z_takeoff])
	des = np.hstack((des,q))
	pub.publish(pose_quadrotor)
	print(np.linalg.norm(med - des))
	if (np.linalg.norm(med - des) <= 0.01):
		print(np.linalg.norm(med - des))
		break;
	rate.sleep()